<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Colourful Sticky Notes App</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            height: 100vh;
            overflow: hidden;
            color: #333;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
            padding: 10px;
        }

        .header h1 {
            color: #fff;
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .btn {
            background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .input-area {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }

        #noteInput {
            width: 100%;
            min-height: 120px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 15px;
            font-size: 1.1rem;
            resize: vertical;
            outline: none;
            transition: border-color 0.3s ease;
        }

        #noteInput:focus {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .notes-wall {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
            align-content: start;
        }

        .note {
            position: relative;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transform: rotate(-1deg);
            transition: all 0.3s ease;
            min-height: 150px;
            display: flex;
            flex-direction: column;
            word-wrap: break-word;
            animation: fadeIn 0.5s ease-out;
            cursor: pointer;
        }

        .note:hover {
            transform: rotate(0deg) scale(1.02);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }

        .note.editing {
            transform: rotate(0deg) scale(1.02);
            box-shadow: 0 0 0 3px #667eea, 0 8px 25px rgba(0,0,0,0.15);
        }

        .note-content {
            flex: 1;
            font-size: 1.2rem;
            line-height: 1.5;
            white-space: pre-wrap;
            color: white;
            font-weight: bold;
        }

        .note-edit {
            flex: 1;
            font-size: 1.2rem;
            line-height: 1.5;
            border: none;
            background: transparent;
            resize: none;
            outline: none;
            font-family: inherit;
            color: white;
            font-weight: bold;
        }

        .note-actions {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .note:hover .note-actions {
            opacity: 1;
        }

        .action-btn {
            background: rgba(255, 255, 255, 0.9);
            border: none;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .delete-btn {
            color: #ff4757;
        }

        .delete-btn:hover {
            background: #ff4757;
            color: white;
            transform: scale(1.1);
        }

        .edit-btn {
            color: #2ed573;
        }

        .edit-btn:hover {
            background: #2ed573;
            color: white;
            transform: scale(1.1);
        }

        .save-btn {
            color: #3742fa;
        }

        .save-btn:hover {
            background: #3742fa;
            color: white;
            transform: scale(1.1);
        }

        .cancel-btn {
            color: #ffa502;
        }

        .cancel-btn:hover {
            background: #ffa502;
            color: white;
            transform: scale(1.1);
        }

        .timestamp {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-top: 10px;
            text-align: right;
        }

        .auto-save-indicator {
            text-align: center;
            margin-top: 10px;
            font-size: 0.9rem;
            color: #667eea;
            opacity: 0;
            transition: opacity 0.3s ease;
            height: 20px;
        }

        .auto-save-indicator.visible {
            opacity: 1;
        }

        .search-container {
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
        }

        .search-input {
            width: 300px;
            padding: 12px 20px;
            border: 2px solid #e0e0e0;
            border-radius: 25px;
            font-size: 1rem;
            outline: none;
            transition: border-color 0.3s ease;
        }

        .search-input:focus {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .status-message {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            border-radius: 10px;
            background: #2ed573;
            color: white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transform: translateX(150%);
            transition: transform 0.3s ease;
            z-index: 1000;
        }

        .status-message.show {
            transform: translateX(0);
        }

        .status-message.error {
            background: #ff4757;
        }

        .status-message.warning {
            background: #ffa502;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px) rotate(-2deg);
            }
            to {
                opacity: 1;
                transform: translateY(0) rotate(-1deg);
            }
        }

        .file-input {
            display: none;
        }

        /* Fluorescent colors for notes */
        .note-color-1 { background: rgba(8, 255, 8, 0.8); }
        .note-color-2 { background: rgba(255, 207, 0, 0.8); }
        .note-color-3 { background: rgba(254, 20, 147, 0.8); }
        .note-color-4 { background: rgba(255, 85, 85, 0.8); }
        .note-color-5 { background: rgba(0, 253, 255, 0.8); }
        .note-color-6 { background: rgba(204, 255, 2, 0.8); }
        /* Removing unused colors */

        /* Scrollbar styling */
        .notes-wall::-webkit-scrollbar {
            width: 8px;
        }

        .notes-wall::-webkit-scrollbar-track {
            background: #fffefe;
            border-radius: 4px;
        }

        .notes-wall::-webkit-scrollbar-thumb {
            background: #fffefe;
            border-radius: 4px;
        }

        .notes-wall::-webkit-scrollbar-thumb:hover {
            background: #f8f7f7;
        }

        @media (max-width: 768px) {
            .app-container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .btn {
                width: 200px;
            }
            
            .notes-wall {
                grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
                padding: 10px;
            }
            
            .search-input {
                width: 100%;
                max-width: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="header">
            <h1>ðŸŽ¨ Colourful Sticky Notes</h1>
        </div>
        
        <div class="controls">
            <button class="btn" id="downloadBtn">ðŸ“¥ Download Backup</button>
            <button class="btn" id="uploadBtn">ðŸ“¤ Upload Backup</button>
            <input type="file" id="fileInput" class="file-input" accept=".sqlite,.json">
        </div>
        
        <div class="input-area">
            <textarea id="noteInput" placeholder="Type your note here... Start typing and wait 3 seconds to auto-save!"></textarea>
            <div class="auto-save-indicator" id="autoSaveIndicator">Auto-saving...</div>
        </div>
        
        <div class="notes-wall" id="notesWall"></div>
    </div>

    <div class="status-message" id="statusMessage"></div>

    <script>
        class StickyNotesApp {
            constructor() {
                this.notes = [];
                this.saveTimer = null;
                this.editingNoteId = null;
                
                // Fluorescent color palette
                this.COLORS = [
                    'note-color-1', 'note-color-2', 'note-color-3', 'note-color-4', 'note-color-5', 'note-color-6'
                ];
                
                this.init();
            }
            
            init() {
                this.loadNotes();
                this.render();
                this.setupEventListeners();
                this.showStatus('App loaded successfully!', 'success');
            }
            
            setupEventListeners() {
                const noteInput = document.getElementById('noteInput');
                const downloadBtn = document.getElementById('downloadBtn');
                const uploadBtn = document.getElementById('uploadBtn');
                const fileInput = document.getElementById('fileInput');
                const notesWall = document.getElementById('notesWall');
                
                // Auto-save functionality
                noteInput.addEventListener('input', () => {
                    this.handleAutoSave();
                });
                
                // Download backup
                downloadBtn.addEventListener('click', () => {
                    this.downloadBackup();
                });
                
                // Upload backup
                uploadBtn.addEventListener('click', () => {
                    fileInput.click();
                });
                
                fileInput.addEventListener('change', (event) => {
                    this.handleFileUpload(event);
                });
                
                // Event delegation for note actions
                notesWall.addEventListener('click', (event) => {
                    const noteElement = event.target.closest('.note');
                    if (!noteElement) return;
                    
                    const noteId = parseInt(noteElement.dataset.id);
                    
                    if (event.target.classList.contains('delete-btn')) {
                        this.deleteNote(noteId);
                    } else if (event.target.classList.contains('edit-btn')) {
                        this.startEditing(noteId);
                    } else if (event.target.classList.contains('save-btn')) {
                        this.saveEditedNote(noteId);
                    } else if (event.target.classList.contains('cancel-btn')) {
                        this.cancelEditing(noteId);
                    }
                });
            }
            
            handleAutoSave() {
                const noteInput = document.getElementById('noteInput');
                const autoSaveIndicator = document.getElementById('autoSaveIndicator');
                
                if (this.saveTimer) {
                    clearTimeout(this.saveTimer);
                }
                
                autoSaveIndicator.classList.add('visible');
                
                this.saveTimer = setTimeout(() => {
                    this.createNote();
                    autoSaveIndicator.classList.remove('visible');
                }, 3000);
            }
            
            createNote() {
                const content = document.getElementById('noteInput').value.trim();
                if (content) {
                    // Get the last used color index or start with -1
                    let lastColorIndex = -1;
                    if (this.notes.length > 0) {
                        const lastColorClass = this.notes[0].colorClass;
                        lastColorIndex = this.COLORS.indexOf(lastColorClass);
                    }
                    
                    // Select the next color in sequence
                    let nextColorIndex = (lastColorIndex + 1) % this.COLORS.length;
                    
                    const note = {
                        id: Date.now(),
                        content: content,
                        colorClass: this.COLORS[nextColorIndex],
                        timestamp: new Date().toISOString()
                    };
                    
                    this.notes.unshift(note);
                    this.saveNotes();
                    this.render();
                    document.getElementById('noteInput').value = '';
                    this.showStatus('Note created successfully!', 'success');
                }
            }
            
            startEditing(noteId) {
                this.cancelEditing(); // Cancel any existing editing
                
                const note = this.notes.find(n => n.id === noteId);
                if (!note) return;
                
                this.editingNoteId = noteId;
                this.render();
                this.showStatus('Editing note...', 'warning');
            }
            
            saveEditedNote(noteId) {
                const noteElement = document.querySelector(`.note[data-id="${noteId}"]`);
                const editTextarea = noteElement.querySelector('.note-edit');
                const newContent = editTextarea.value.trim();
                
                if (newContent) {
                    const noteIndex = this.notes.findIndex(n => n.id === noteId);
                    if (noteIndex !== -1) {
                        this.notes[noteIndex].content = newContent;
                        this.notes[noteIndex].timestamp = new Date().toISOString();
                        this.saveNotes();
                        this.editingNoteId = null;
                        this.render();
                        this.showStatus('Note updated successfully!', 'success');
                    }
                } else {
                    this.showStatus('Note content cannot be empty!', 'error');
                }
            }
            
            cancelEditing(noteId = null) {
                if (noteId && this.editingNoteId !== noteId) return;
                
                this.editingNoteId = null;
                this.render();
            }
            
            deleteNote(id) {
                if (confirm('Are you sure you want to delete this note?')) {
                    this.notes = this.notes.filter(note => note.id !== id);
                    this.saveNotes();
                    this.render();
                    this.showStatus('Note deleted successfully!', 'success');
                }
            }
            
            loadNotes() {
                try {
                    const savedNotes = localStorage.getItem('stickyNotes');
                    if (savedNotes) {
                        this.notes = JSON.parse(savedNotes);
                    }
                } catch (error) {
                    console.error('Error loading notes:', error);
                    this.showStatus('Error loading notes from storage', 'error');
                }
            }
            
            saveNotes() {
                try {
                    const notesString = JSON.stringify(this.notes);
                    const storageSize = this.getStorageSize();
                    
                    // Check if we're approaching storage limits (5MB is typical limit)
                    if (storageSize > 4000000) { // 4MB warning threshold
                        this.showStatus('Warning: Storage is almost full! Consider downloading a backup.', 'warning');
                    }
                    
                    localStorage.setItem('stickyNotes', notesString);
                } catch (error) {
                    if (error.name === 'QuotaExceededError' || error.code === 22 || error.code === 1014) {
                        this.showStatus('Storage full! Please delete some notes or export them.', 'error');
                        this.downloadJSONBackup(); // Auto-backup when storage is full
                    } else {
                        console.error('Error saving notes:', error);
                        this.showStatus('Error saving notes', 'error');
                    }
                }
            }
            
            // Calculate approximate localStorage size
            getStorageSize() {
                let total = 0;
                for (let key in localStorage) {
                    if (localStorage.hasOwnProperty(key)) {
                        total += (localStorage[key].length * 2); // Approximate size in bytes
                    }
                }
                return total;
            }
            
            render() {
                const notesWall = document.getElementById('notesWall');
                
                // Use DocumentFragment for better performance
                const fragment = document.createDocumentFragment();
                
                this.notes.forEach(note => {
                    const noteElement = this.createNoteElement(note);
                    fragment.appendChild(noteElement);
                });
                
                notesWall.innerHTML = '';
                notesWall.appendChild(fragment);
            }
            
            createNoteElement(note) {
                const noteElement = document.createElement('div');
                noteElement.className = `note ${note.colorClass}`;
                noteElement.dataset.id = note.id;
                
                if (this.editingNoteId === note.id) {
                    noteElement.classList.add('editing');
                    
                    const editTextarea = document.createElement('textarea');
                    editTextarea.className = 'note-edit';
                    editTextarea.value = note.content;
                    
                    const actionsElement = document.createElement('div');
                    actionsElement.className = 'note-actions';
                    
                    const saveBtn = document.createElement('button');
                    saveBtn.className = 'action-btn save-btn';
                    saveBtn.innerHTML = 'âœ“';
                    saveBtn.title = 'Save';
                    
                    const cancelBtn = document.createElement('button');
                    cancelBtn.className = 'action-btn cancel-btn';
                    cancelBtn.innerHTML = 'âœ•';
                    cancelBtn.title = 'Cancel';
                    
                    actionsElement.appendChild(saveBtn);
                    actionsElement.appendChild(cancelBtn);
                    
                    const timestampElement = document.createElement('div');
                    timestampElement.className = 'timestamp';
                    timestampElement.textContent = this.formatTimestamp(note.timestamp);
                    
                    noteElement.appendChild(editTextarea);
                    noteElement.appendChild(actionsElement);
                    noteElement.appendChild(timestampElement);
                } else {
                    const contentElement = document.createElement('div');
                    contentElement.className = 'note-content';
                    contentElement.textContent = note.content;
                    
                    const actionsElement = document.createElement('div');
                    actionsElement.className = 'note-actions';
                    
                    const editBtn = document.createElement('button');
                    editBtn.className = 'action-btn edit-btn';
                    editBtn.innerHTML = 'âœŽ';
                    editBtn.title = 'Edit';
                    
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'action-btn delete-btn';
                    deleteBtn.innerHTML = 'Ã—';
                    deleteBtn.title = 'Delete';
                    
                    actionsElement.appendChild(editBtn);
                    actionsElement.appendChild(deleteBtn);
                    
                    const timestampElement = document.createElement('div');
                    timestampElement.className = 'timestamp';
                    timestampElement.textContent = this.formatTimestamp(note.timestamp);
                    
                    noteElement.appendChild(contentElement);
                    noteElement.appendChild(actionsElement);
                    noteElement.appendChild(timestampElement);
                }
                
                return noteElement;
            }
            
            formatTimestamp(timestamp) {
                const date = new Date(timestamp);
                return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            }
            
            showStatus(message, type = 'success') {
                const statusElement = document.getElementById('statusMessage');
                statusElement.textContent = message;
                statusElement.className = 'status-message';
                
                if (type === 'error') {
                    statusElement.classList.add('error');
                } else if (type === 'warning') {
                    statusElement.classList.add('warning');
                }
                
                statusElement.classList.add('show');
                
                setTimeout(() => {
                    statusElement.classList.remove('show');
                }, 3000);
            }
            
            async downloadBackup() {
                try {
                    // Check if SQL.js is available
                    if (typeof initSqlJs === 'function') {
                        await this.downloadSQLiteBackup();
                    } else {
                        // Fallback to JSON if SQL.js is not available
                        console.log('SQL.js not available, using JSON backup');
                        this.downloadJSONBackup();
                    }
                } catch (error) {
                    console.error('Error creating SQLite backup, falling back to JSON:', error);
                    this.downloadJSONBackup();
                }
            }
            
            async downloadSQLiteBackup() {
                const SQL = await initSqlJs({
                    locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`
                });
                
                const db = new SQL.Database();
                
                db.run(`
                    CREATE TABLE notes (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        content TEXT,
                        colorClass TEXT,
                        timestamp TEXT
                    )
                `);
                
                const stmt = db.prepare(`
                    INSERT INTO notes (id, content, colorClass, timestamp) VALUES (?, ?, ?, ?)
                `);
                
                this.notes.forEach(note => {
                    stmt.run([note.id, note.content, note.colorClass, note.timestamp]);
                });
                
                stmt.free();
                
                const data = db.export();
                const buffer = new Uint8Array(data);
                
                const blob = new Blob([buffer], { type: 'application/x-sqlite3' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'stickynotes_backup.sqlite';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                db.close();
                this.showStatus('Backup downloaded successfully!', 'success');
            }
            
            downloadJSONBackup() {
                const dataStr = JSON.stringify(this.notes, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'stickynotes_backup.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                this.showStatus('JSON backup downloaded successfully!', 'success');
            }
            
            async handleFileUpload(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                if (!confirm('Importing will overwrite all existing notes. Continue?')) {
                    event.target.value = '';
                    return;
                }
                
                try {
                    if (file.name.endsWith('.sqlite')) {
                        await this.importSQLiteBackup(file);
                    } else if (file.name.endsWith('.json')) {
                        await this.importJSONBackup(file);
                    } else {
                        throw new Error('Unsupported file format');
                    }
                } catch (error) {
                    console.error('Error importing backup:', error);
                    this.showStatus('Error importing backup. Please make sure the file is valid.', 'error');
                } finally {
                    event.target.value = '';
                }
            }
            
            async importSQLiteBackup(file) {
                const SQL = await initSqlJs({
                    locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`
                });
                
                const arrayBuffer = await file.arrayBuffer();
                const uint8Array = new Uint8Array(arrayBuffer);
                const db = new SQL.Database(uint8Array);
                
                const result = db.exec("SELECT id, content, colorClass, timestamp FROM notes");
                
                if (result.length > 0) {
                    const columns = result[0].columns;
                    const values = result[0].values;
                    
                    this.notes = values.map(row => {
                        const note = {};
                        columns.forEach((col, index) => {
                            note[col] = row[index];
                        });
                        return note;
                    });
                    
                    this.saveNotes();
                    this.render();
                    this.showStatus('SQLite backup imported successfully!', 'success');
                } else {
                    this.showStatus('No notes found in the backup file.', 'warning');
                }
                
                db.close();
            }
            
            async importJSONBackup(file) {
                const text = await file.text();
                const importedNotes = JSON.parse(text);
                
                if (Array.isArray(importedNotes)) {
                    this.notes = importedNotes;
                    this.saveNotes();
                    this.render();
                    this.showStatus('JSON backup imported successfully!', 'success');
                } else {
                    throw new Error('Invalid JSON format');
                }
            }
        }

        // Initialize the application when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            window.stickyNotesApp = new StickyNotesApp();
        });
    </script>
</body>
</html>
